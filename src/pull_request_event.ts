import assert from 'node:assert'
import * as core from '@actions/core'
import type { Octokit } from '@octokit/action'
import type { PullRequestEvent } from '@octokit/webhooks-types'
import { getAutoGeneratedTrailer, hasConsecutiveAutoGeneratedCommits } from './commit.js'
import * as git from './git.js'
import type { Context } from './github.js'
import type { Outputs } from './run.js'

export type Inputs = {
  commitMessage: string
  commitMessageFooter: string
  dryRun: boolean
}

export const handlePullRequestEvent = async (
  inputs: Inputs,
  context: Context<PullRequestEvent>,
  octokit: Octokit,
): Promise<Outputs> => {
  if (await hasConsecutiveAutoGeneratedCommits(context.payload.pull_request.head.sha)) {
    throw new Error(`Detected consecutive auto-generated commits. Stopped execution to prevent an infinite loop.`)
  }

  const currentCommitIsMergeCommit = (await git.getCurrentSHA()) === context.sha
  if (currentCommitIsMergeCommit) {
    await cherryPickWorkspaceChangesOntoMergeCommit(inputs, context, octokit)
  } else {
    core.info(`Committing the workspace changes on the head branch directly`)
    await git.commit([inputs.commitMessage, inputs.commitMessageFooter, getAutoGeneratedTrailer(context)])
  }
  await git.showGraph()

  const headRef = context.payload.pull_request.head.ref
  core.info(`Updating the head branch ${headRef}`)
  await git.push({ localRef: `HEAD`, remoteRef: `refs/heads/${headRef}`, dryRun: inputs.dryRun })

  if (context.payload.action === 'opened' || context.payload.action === 'synchronize') {
    // Fail if the head ref is outdated
    core.summary.addRaw(`Added a commit. CI should pass on the new commit.`)
    await core.summary.write()
    if (inputs.dryRun) {
      core.warning(`[dry-run] Added a commit. CI should pass on the new commit.`)
      return {}
    }
    throw new Error(`Added a commit. CI should pass on the new commit.`)
  }
  return {}
}

const cherryPickWorkspaceChangesOntoMergeCommit = async (
  inputs: Inputs,
  context: Context<PullRequestEvent>,
  octokit: Octokit,
) => {
  core.info(`Cherry-pick the workspace changes onto the merge commit`)
  await git.commit([inputs.commitMessage, inputs.commitMessageFooter, getAutoGeneratedTrailer(context)])
  const workspaceChangeSHA = await git.getCurrentSHA()

  const parentSHAs = await git.getParentSHAs(context.sha)
  const headSHA = context.payload.pull_request.head.sha
  const baseSHA = parentSHAs.filter((sha) => sha !== headSHA).pop()
  assert(baseSHA !== undefined, `context.sha ${context.sha} must be a merge commit`)
  await fetchCommitsBetweenBaseHead(baseSHA, headSHA)

  await git.checkout(headSHA)

  // TODO: uncomment
  // if (await git.tryCherryPick(workspaceChangeSHA)) {
  //   await signCurrentCommit(context, octokit)
  //   return
  // }

  // If this action pushes the merge commit (refs/pull/x/merge) into the head branch,
  // we may see the unrelated diff in the pull request diff.
  // To avoid that issue, recreate a merge commit by base into head strategy.
  // https://github.com/int128/update-generated-files-action/issues/351
  core.info(`Re-merging base branch into head branch`)
  await git.checkout(headSHA)
  const headRef = context.payload.pull_request.head.ref
  const baseRef = context.payload.pull_request.base.ref
  await git.merge(baseSHA, [`Merge branch '${baseRef}' into ${headRef}`, getAutoGeneratedTrailer(context)])
  const mergeCommitIsCreated = (await git.getCurrentSHA()) !== headSHA
  if (mergeCommitIsCreated) {
    await signCurrentCommit(context, octokit)
  }
  await git.cherryPick(workspaceChangeSHA)
  await signCurrentCommit(context, octokit)
}

const fetchCommitsBetweenBaseHead = async (baseSHA: string, headSHA: string) => {
  for (let depth = 50; depth < 1000; depth += 50) {
    if (await git.canMerge(baseSHA, headSHA)) {
      core.info(`Fetched commits required to merge base and head`)
      return
    }
    await git.fetch({ refs: [baseSHA, headSHA], depth })
  }
}

const signCurrentCommit = async (context: Context, octokit: Octokit) => {
  const unsignedCommitSHA = await git.getCurrentSHA()
  await git.showGraph()
  const signingBranch = `signing--${unsignedCommitSHA}`
  await git.push({ localRef: unsignedCommitSHA, remoteRef: `refs/heads/${signingBranch}`, dryRun: false })
  try {
    const { data: unsignedCommit } = await octokit.rest.git.getCommit({
      owner: context.repo.owner,
      repo: context.repo.repo,
      commit_sha: unsignedCommitSHA,
    })
    const { data: signedCommit } = await octokit.rest.git.createCommit({
      owner: context.repo.owner,
      repo: context.repo.repo,
      message: unsignedCommit.message,
      tree: unsignedCommit.tree.sha,
      parents: unsignedCommit.parents.map((parent) => parent.sha),
    })
    await octokit.rest.git.updateRef({
      owner: context.repo.owner,
      repo: context.repo.repo,
      ref: `heads/${signingBranch}`,
      sha: signedCommit.sha,
      force: true,
    })
    await git.showGraph()
    await git.fetch({ refs: [signedCommit.sha], depth: 1 })
    await git.showGraph()
    await git.checkout(signedCommit.sha)
    await git.showGraph()
  } finally {
    await git.deleteRef(`refs/heads/${signingBranch}`)
  }
}
