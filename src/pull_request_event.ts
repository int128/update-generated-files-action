import * as core from '@actions/core'
import * as git from './git'
import * as github from '@actions/github'
import { Inputs } from './run'
import { Context } from '@actions/github/lib/context'
import { WebhookPayload } from '@actions/github/lib/interfaces'

export type PullRequestContext = Pick<Context, 'ref' | 'workflow' | 'job' | 'runId' | 'serverUrl' | 'repo'> & {
  payload: Pick<WebhookPayload, 'action'> & {
    pull_request?: {
      head: {
        ref: string
      }
    }
  }
}

export const handlePullRequestEvent = async (inputs: Inputs, context: PullRequestContext) => {
  const octokit = github.getOctokit(inputs.token)
  if (context.payload.pull_request === undefined) {
    throw new Error(`context.payload.pull_request is undefined`)
  }
  const head = context.payload.pull_request.head.ref

  core.info(`Updating the head branch ${head}`)
  await git.fetchBranch({ ref: context.ref, depth: 2, token: inputs.token })
  await git.updateBranch({
    ref: `refs/heads/${head}`,
    commitMessage: commitMessage(inputs.title, context),
    token: inputs.token,
  })

  core.summary.addRaw(`Added a commit. CI should pass on the new commit.`)
  await core.summary.write()

  for (const workflow_id of inputs.dispatchWorkflows) {
    core.info(`Creating a workflow dispatch to ${workflow_id}`)
    await octokit.rest.actions.createWorkflowDispatch({
      owner: context.repo.owner,
      repo: context.repo.repo,
      ref: head,
      workflow_id,
    })
  }

  if (context.payload.action === 'opened' || context.payload.action === 'synchronize') {
    // fail if the head ref is outdated
    throw new Error(`Added a commit. CI should pass on the new commit.`)
  }
  return
}

const commitMessage = (
  title: string,
  context: PullRequestContext
) => `Generated by GitHub Actions (${context.workflow} / ${context.job})

${title}
${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
